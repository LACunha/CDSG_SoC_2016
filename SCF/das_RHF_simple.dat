import numpy as np

molecule mol {
    H
    H 1 0.74
symmetry c1
}

tol = 1.e-13

wfn = psi4.new_wavefunction(mol, '6-31G')
set basis 6-31G

mints = psi4.MintsHelper(wfn.basisset())

# Get overlap & core Hamiltonian matrices from Mints Helper
S = np.asarray(mints.ao_overlap())
T = np.asarray(mints.ao_kinetic())
V = np.asarray(mints.ao_potential())
H = T + V

# Build the transformation matrix A = S^(-1/2)
## Diagonalize S, get eigenvalues & eigenvectors
S_eigvals, S_eigvec = np.linalg.eigh(S)
## Take negative sqrt of diagonal S
negsqrt_S_eigvals = S_eigvals ** (-0.5)
## Transform neg_sqrt(S) into A
A = np.einsum('ip,p,pj', S_eigvec, negsqrt_S_eigvals, S_eigvec)

# Build orthogonal Fock matrix using H
F_p = np.dot(A.T, H).dot(A)

# Get eigenvalues & eigenvectors of F_p
F_p_eigvals, C2 = np.linalg.eigh(F_p)

# Trnasform back to C from C2, get occupied orbital coefficients
C = np.dot(A, C2)

# Get number of doubly occupied orbitals, slice occupied block of C
n_docc = wfn.nalpha() # RHF for closed shell 
C_occ = C[:, :n_docc]

# Build one-particle density matrix
D = np.dot(C_occ, C_occ.T)

# Build eri tensor
## Check size of ERI tensor for memory storage
num_basis_funct = S.shape[0]
g_size = ((num_basis_funct ** 4) * 8) / 1.e9
if g_size > 1:
    raise Exception("ERI tensor is too big for memory!")

g = np.asarray(mints.ao_eri())

# Build J & K matrices
J = 2 * np.einsum('pqrs,rs->pq', g, D)
K = np.einsum('prqs,rs->pq', g, D)

# Build updated Fock matrix
F = H + J - K

# Compute first energy guess
E_elec = np.einsum('pq,pq->', H + F, D)
E_nuc = mol.nuclear_repulsion_energy()
E_old = E_elec + E_nuc

dE = 1
SCF_ITER = 1
while abs(dE) >= tol:
    # Orthogonalize F
    F_p = np.dot(A.T, F).dot(A)
    # Get eigenvectors of F_p
    F_p_evals, C2 = np.linalg.eigh(F_p)
    # Transform C2 into AO Basis
    C = np.dot(A, C2)

    # Grab occupied AO coefficients
    C_occ = C[:, :n_docc] 
    # Build one-particle density matrix
    D = np.dot(C_occ, C_occ.T)
    
    # Update J, K, F
    J = 2 * np.einsum('pqrs,rs->pq', g, D)
    K = np.einsum('prqs,rs->pq', g, D)
    F = H + J - K

    # Compute energies
    E_elec = np.einsum('pq,pq->', H + F, D)
    E_nuc = mol.nuclear_repulsion_energy()
    SCF_E = E_elec + E_nuc
    dE = SCF_E - E_old

    print('SCF Iteration %3d:\tEnergy = %4.16f\tdE = %4.16f' 
    % (SCF_ITER, SCF_E, dE))
    
    # Update iteratives
    E_old = SCF_E
    SCF_ITER += 1        

print('Electronic energy is     %12.10f' % E_elec)
print('Nuclear energy is         %12.10f' % E_nuc)
print('Total energy is          %12.10f' % SCF_E)

set scf_type pk
set e_convergence 1.e-14
print('Total energy from psi4:  %12.10f' % energy('SCF'))
